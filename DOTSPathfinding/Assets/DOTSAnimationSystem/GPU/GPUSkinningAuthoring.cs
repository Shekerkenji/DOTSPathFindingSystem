using Unity.Collections;
using Unity.Entities;
using UnityEngine;
using UnityEngine.Rendering;

namespace Shek.ECSAnimation
{
    /// <summary>
    /// Attach to your character prefab root alongside AnimationLibraryAuthoring.
    ///
    /// Setup:
    ///   1. Run Tools → DOTS Animation → Bake GPU Skinning Texture.
    ///   2. Assign AnimTex, BakedMesh, GPUSkinLib, and Material here.
    ///      (No BindTex needed — bind poses are pre-multiplied into AnimTex at bake time.)
    ///   3. Remove SkinnedMeshAuthoring from mesh child GameObjects.
    ///   4. Disable or remove the SkinnedMeshRenderer on the mesh child.
    /// </summary>
    [DisallowMultipleComponent]
    public class GPUSkinningAuthoring : MonoBehaviour
    {
        [Header("Baked Assets (generated by Tools > DOTS Animation > Bake GPU Skinning Texture)")]
        public Texture2D animationTexture;
        public Mesh bakedMesh;
        public GPUSkinningLibraryAsset libraryAsset;

        [Header("Material")]
        [Tooltip("Must use the Shek.ECSAnimation/GPUSkinning shader.")]
        public Material material;

        [Header("Rendering")]
        public ShadowCastingMode shadowCasting = ShadowCastingMode.On;
        public bool receiveShadows = true;
        public int layer = 0;
    }

    public class GPUSkinningBaker : Baker<GPUSkinningAuthoring>
    {
        public override void Bake(GPUSkinningAuthoring authoring)
        {
            if (authoring.animationTexture == null || authoring.bakedMesh == null
                || authoring.libraryAsset == null || authoring.material == null)
            {
                Debug.LogError($"[GPUSkinningBaker] Missing assets on '{authoring.gameObject.name}'. " +
                               "Run the GPU Skinning Baker first.");
                return;
            }

            var entity = GetEntity(TransformUsageFlags.Dynamic);
            var libBlob = BuildLibraryBlob(authoring.libraryAsset);
            if (!libBlob.IsCreated) return;

            AddBlobAsset(ref libBlob, out _);
            AddComponent(entity, new GPUSkinningLibraryReference { Value = libBlob });
            AddComponent(entity, new GPUSkinningData { RendererIndex = -1 });
            AddComponent(entity, new GPUSkinningTag());

            AddComponentObject(entity, new GPUSkinningManagedData
            {
                AnimationTexture = authoring.animationTexture,
                BakedMesh = authoring.bakedMesh,
                Material = new Material(authoring.material),
                ShadowCasting = authoring.shadowCasting,
                ReceiveShadows = authoring.receiveShadows,
                Layer = authoring.layer
            });
        }

        static BlobAssetReference<GPUSkinningLibraryBlob> BuildLibraryBlob(GPUSkinningLibraryAsset asset)
        {
            if (asset?.clips == null) return default;
            var builder = new BlobBuilder(Allocator.Temp);
            ref var root = ref builder.ConstructRoot<GPUSkinningLibraryBlob>();
            root.BoneCount = asset.boneCount;
            root.TotalFrames = asset.totalFrames;
            var arr = builder.Allocate(ref root.Clips, asset.clips.Length);
            for (int i = 0; i < asset.clips.Length; i++)
            {
                var s = asset.clips[i];
                arr[i] = new GPUClipInfo
                {
                    TextureRowOffset = s.textureRowOffset,
                    FrameCount = s.frameCount,
                    Duration = s.duration,
                    FrameRate = s.frameRate,
                    IsLooping = s.isLooping
                };
            }
            var result = builder.CreateBlobAssetReference<GPUSkinningLibraryBlob>(Allocator.Persistent);
            builder.Dispose();
            return result;
        }
    }

    /// <summary>
    /// Managed component holding Unity Object references for the render system.
    /// No BindPoseTexture — it's baked into AnimationTexture at bake time.
    /// </summary>
    public class GPUSkinningManagedData : IComponentData
    {
        public Texture2D AnimationTexture;
        public Mesh BakedMesh;
        public Material Material;
        public ShadowCastingMode ShadowCasting;
        public bool ReceiveShadows;
        public int Layer;
    }
}