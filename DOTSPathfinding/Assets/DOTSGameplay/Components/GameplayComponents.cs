using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;

namespace Shek.ECSGameplay
{
    // ?????????????????????????????????????????????
    // IDENTITY & STATS
    // ?????????????????????????????????????????????

    public struct UnitData : IComponentData
    {
        public FixedString64Bytes Name;
        /// <summary>Capsule radius — used for melee slot geometry and target sizing.</summary>
        public float Radius;
        /// <summary>Faction ID — units with matching factions do not attack each other.</summary>
        public int FactionId;
    }

    public struct FactionTag : IComponentData
    {
        public int FactionId;
    }

    // ?????????????????????????????????????????????
    // HEALTH & REGENERATION
    // ?????????????????????????????????????????????

    public struct HealthComponent : IComponentData
    {
        public int Current;
        public int Max;
        /// <summary>HP per second regenerated when out of combat.</summary>
        public float RegenRate;
        /// <summary>Seconds since last damage — regen begins after OutOfCombatDelay.</summary>
        public float TimeSinceLastDamage;
        public float OutOfCombatDelay;
    }

    // ?????????????????????????????????????????????
    // MOVEMENT
    // ?????????????????????????????????????????????

    /// <summary>Gameplay-level movement overrides layered on top of NavigationComponents.</summary>
    public struct MovementComponent : IComponentData
    {
        public float CurrentSpeed;
        public float BaseSpeed;
    }

    // ?????????????????????????????????????????????
    // LEVEL & PROGRESSION
    // ?????????????????????????????????????????????

    public struct Level : IComponentData
    {
        public int Current;
        public int CurrentEXP;
        public int EXPToNextLevel;
        public int StatPointsPerLevel;
        public int AvailableStatPoints;
    }

    // ?????????????????????????????????????????????
    // WEAPON
    // ?????????????????????????????????????????????

    public enum WeaponType : byte
    {
        None = 0,
        Melee = 1,
        Ranged = 2,
        MeleeAOE = 3,
        RangedAOE = 4,
    }

    public struct Weapon : IComponentData, IEnableableComponent
    {
        public FixedString64Bytes Name;
        public WeaponType Type;
        /// <summary>Multiplied by AttackComponent.BaseDamage to get final damage.</summary>
        public float DamageMult;
        /// <summary>World-units. For melee this defines the orbit radius from target edge.</summary>
        public float Range;
        /// <summary>Multiplied by AttackComponent.BaseAttackSpeed to reduce cooldown.</summary>
        public float SpeedMult;
        /// <summary>For ranged: max los raycast distance (0 = use Range).</summary>
        public float DetectionRange;
    }

    // ?????????????????????????????????????????????
    // ATTACK
    // ?????????????????????????????????????????????

    public struct AttackComponent : IComponentData
    {
        public int BaseDamage;
        public float BaseAttackSpeed;   // Attacks per second before weapon modifier
        public float AttackCooldown;    // Computed: 1f / (BaseAttackSpeed * Weapon.SpeedMult)
        public float LastAttackTime;
        // Gate: Time >= LastAttackTime + AttackCooldown
    }

    // ?????????????????????????????????????????????
    // AI STATE MACHINE
    // ?????????????????????????????????????????????

    public enum UnitState : byte
    {
        Idle = 0,
        Moving = 1,
        Attacking = 2,
        Hit = 3,
        Dead = 4,
        Immobilized = 5,
    }

    public struct AIState : IComponentData
    {
        public UnitState State;
        /// <summary>How long the current state has been active.</summary>
        public float StateTimer;
    }

    // ?????????????????????????????????????????????
    // DETECTION & TARGETING
    // ?????????????????????????????????????????????

    /// <summary>
    /// Parameters that drive the threat scanner.
    /// All radii are in world units. Line-of-sight checks are applied for ranged units.
    /// </summary>
    public struct DetectionComponent : IComponentData
    {
        /// <summary>Radius within which this unit scans for enemies.</summary>
        public float DetectionRadius;
        /// <summary>If a target runs beyond this range, disengage.</summary>
        public float ChaseRange;
        /// <summary>Notify allies within this radius about a new target.</summary>
        public float PingRadius;
        /// <summary>Physics layer mask for LoS raycasts (walls / obstacles).</summary>
        public int ObstacleLayers;
        /// <summary>How many seconds between full threat re-scans.</summary>
        public float ScanInterval;
        public float NextScanTime;
    }

    /// <summary>
    /// Persisted result of the last threat scan.
    /// Written by ThreatScanSystem; read by AIDecisionSystem.
    /// </summary>
    public struct CurrentTarget : IComponentData
    {
        public Entity TargetEntity;
        public float3 LastKnownPosition;
        /// <summary>Set to 1 when TargetEntity is valid.</summary>
        public byte HasTarget;
    }

    // ?????????????????????????????????????????????
    // MELEE SLOT MANAGEMENT
    // ?????????????????????????????????????????????

    /// <summary>
    /// Tracks how many melee attackers are currently orbiting this entity.
    /// Written by MeleeSlotSystem; read by ThreatScanSystem scoring.
    /// </summary>
    public struct MeleeSlotComponent : IComponentData
    {
        public int CurrentMeleeAttackers;
        public int CurrentRangedAttackers;
        /// <summary>
        /// Max simultaneous melee attackers allowed around this target,
        /// computed from target radius: Floor(2? * (targetRadius + avgAttackerRadius) / avgAttackerDiameter).
        /// </summary>
        public int MaxMeleeSlots;
    }

    /// <summary>
    /// Written onto an attacking unit to record which slot index it occupies on the target.
    /// SlotIndex drives the angle formula for orbit positioning.
    /// </summary>
    public struct MeleeSlotAssignment : IComponentData, IEnableableComponent
    {
        public Entity TargetEntity;
        public int SlotIndex;
        public int TotalSlots;
    }

    // ?????????????????????????????????????????????
    // DAMAGE EVENTS  (one-shot enableable)
    // ?????????????????????????????????????????????

    /// <summary>Raised on the ATTACKER when an attack lands.</summary>
    public struct AttackHitEvent : IComponentData, IEnableableComponent
    {
        public Entity HitTarget;
        public int Damage;
    }

    /// <summary>Raised on the VICTIM when it receives damage.</summary>
    public struct DamageReceivedEvent : IComponentData, IEnableableComponent
    {
        public Entity Attacker;
        public int Damage;
    }

    // ?????????????????????????????????????????????
    // DEATH
    // ?????????????????????????????????????????????

    public struct DeadTag : IComponentData, IEnableableComponent { }

    // ?????????????????????????????????????????????
    // COMBAT AUTHORING HELPER (non-ECS, not IComponentData)
    // ?????????????????????????????????????????????
    // See CombatAgentAuthoring.cs for the MonoBehaviour + Baker.
}